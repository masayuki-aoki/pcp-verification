#Appendix A
# Colab-ready, single cell (conservative): A=3, C_BV=5.0
import sys; assert sys.version_info >= (3,11), "Use Python 3.11+ (Decimal.ln)"
import math
from fractions import Fraction
from decimal import Decimal, getcontext, ROUND_FLOOR, ROUND_CEILING

getcontext().prec = 80

# ---------- exact V(z) with mod-3 gate (exclude l=3) ----------
def sieve_isprime(n: int):
    s = [True]*(n+1); s[0]=s[1]=False
    p=2
    while p*p<=n:
        if s[p]:
            s[p*p:n+1:p] = [False]*(((n-p*p)//p)+1)
        p+=1
    return s

def V_rational(X: int) -> tuple[int, Fraction]:
    z = int(math.isqrt(X)) + 1
    isp = sieve_isprime(z)
    V = Fraction(1,1)
    for l in range(5, z+1):   # l >= 5 (mod-3 gate handled here)
        if isp[l]:
            V *= Fraction(l-2, l-1)
    return z, V

# ---------- safe lower/upper helpers ----------
def li_lower(X: int) -> Decimal:
    # lower bound: li(X) >= X/log X
    getcontext().rounding = ROUND_FLOOR
    L = Decimal(X).ln()
    return (Decimal(X)/L)

def BV_upper(X: int, A: int, C_str: str) -> Decimal:
    # upper bound: C*X/(log X)^A
    getcontext().rounding = ROUND_CEILING
    C = Decimal(C_str); L = Decimal(X).ln()
    return (C*Decimal(X))/(L**A)

# ---------- main certificate ----------
def pcp_lower_doubleBV(X: int, A: int=3, C_AP: str="5.0", C_AGG: str="5.0",
                       print_sanity: bool=False) -> Decimal:
    z, V = V_rational(X)
    Vd = Decimal(V.numerator)/Decimal(V.denominator)

    # f(3) down; li down
    f3 = Decimal("0.8230302166065229129458236")
    main = (li_lower(X)/Decimal(2)) * Vd * f3

    # BV penalties up
    BV_AP  = BV_upper(X, A, C_AP)  * Vd * f3
    BV_AGG = BV_upper(X, A, C_AGG)

    # r5: subtract 1 iff X-3 is prime (exception r=5 survives)
    isp = sieve_isprime(X)     # enough up to X
    r5  = Decimal(1) if (X-3>=2 and isp[X-3]) else Decimal(0)

    getcontext().rounding = ROUND_FLOOR
    PCp_lower = main - BV_AP - BV_AGG - r5

    if print_sanity:
        denom = Decimal(X)/(Decimal(X).ln()**2)
        c_main = main/denom
        print(f"-- sanity at X={X:,} --")
        print(f"[li_lower]={li_lower(X)}")
        print(f"[V_lower] ={Vd}")
        print(f"[f(3)]    ={f3}")
        print(f"[main]    ={main} | X/log^2X={denom} | c_main={c_main}")
        print(f"[BV_AP]   ={BV_AP} | [BV_AGG]={BV_AGG} | r5={r5}")
        print(f"[PCp_lower]={PCp_lower}\n")
    return PCp_lower

# --- demo: certify the window [80k,90k] (main statement) ---
pcp_lower_doubleBV(100_000, A=3, C_AP="5.0", C_AGG="5.0", print_sanity=True)

print("=== doubleBV, C_AP=C_AGG=5.0 ===")
for X in [80_000, 100_000, 120_000, 150_000, 200_000, 300_000, 500_000, 1_000_000]:
    val = pcp_lower_doubleBV(X, A=3, C_AP="5.0", C_AGG="5.0", print_sanity=False)
    status = "[OK-cert]" if val>0 else "[NO]"
    print(f"X={X:9,d}  PCp_lower≥{val}  {status}")

# Expected (abridged, matches paper logs):
# -- sanity at X=100,000 --
# [PCp_lower] ~ 5.1235e+02 > 0
# Window [80k,90k]: all positive

###########################################################################################################################
#Appendix B
# Colab-ready, single cell (optimized): A=3, C_BV=3.0
import sys; assert sys.version_info >= (3,11), "Use Python 3.11+ (Decimal.ln)"
import math
from fractions import Fraction
from decimal import Decimal, getcontext, ROUND_FLOOR, ROUND_CEILING

getcontext().prec = 80

def sieve_isprime(n: int):
    s = [True]*(n+1); s[0]=s[1]=False
    p=2
    while p*p<=n:
        if s[p]:
            s[p*p:n+1:p] = [False]*(((n-p*p)//p)+1)
        p+=1
    return s

def V_rational(X: int):
    z = int(math.isqrt(X)) + 1
    isp = sieve_isprime(z)
    V = Fraction(1,1)
    for l in range(5, z+1):
        if isp[l]:
            V *= Fraction(l-2,l-1)
    return z, V

def li_lower(X: int) -> Decimal:
    getcontext().rounding = ROUND_FLOOR
    L = Decimal(X).ln()
    return (Decimal(X)/L)

def BV_upper(X: int, A: int, C_str: str) -> Decimal:
    getcontext().rounding = ROUND_CEILING
    C = Decimal(C_str); L = Decimal(X).ln()
    return (C*Decimal(X))/(L**A)

def pcp_lower_doubleBV_opt(X: int, A: int=3, C: str="3.0") -> Decimal:
    z, V = V_rational(X)
    Vd = Decimal(V.numerator)/Decimal(V.denominator)
    f3 = Decimal("0.8230302166065229129458236")
    main = (li_lower(X)/Decimal(2)) * Vd * f3
    BV_AP  = BV_upper(X,A,C) * Vd * f3
    BV_AGG = BV_upper(X,A,C)
    # r5 as in conservative cell
    isp = sieve_isprime(X)
    r5  = Decimal(1) if (X-3>=2 and isp[X-3]) else Decimal(0)
    getcontext().rounding = ROUND_FLOOR
    return main - BV_AP - BV_AGG - r5

# demo
print("-- optimized sanity at X=50,000 --")
val = pcp_lower_doubleBV_opt(50_000, A=3, C="3.0")
print("PCp_lower =", val, "[OK-cert]" if val>0 else "[NO]")

print("=== doubleBV, C_AP=C_AGG=3.0 (optimized) ===")
for X in [50_000, 60_000, 80_000, 100_000]:
    val = pcp_lower_doubleBV_opt(X, A=3, C="3.0")
    print(f"X={X:9,d}  PCp_lower≥{val}  {'[OK-cert]' if val>0 else '[NO]'}")

# Expected (abridged):
# X=   50,000 ... PCp_lower ~ 3.72e+02 [OK-cert]
# Window [50k,60k]: all positive

###########################################################################################################################
#Appendix C
# Colab-ready: exact PCp(X) for X <= Xmax via FFT
import numpy as np

def sieve_isprime(n: int) -> np.ndarray:
    s = np.ones(n+1, dtype=np.bool_); s[:2] = False
    p=2
    while p*p<=n:
        if s[p]:
            s[p*p:n+1:p] = False
        p+=1
    return s

def pcp_exact_up_to_fft(Xmax: int = 80_000):
    # 1) primes up to Xmax+2 (need q+2)
    isprime = sieve_isprime(Xmax + 2)

    # 2) build T[q] on q=0..Xmax: 1_{q composite, q>=4, (q+2) prime}
    L = Xmax + 1
    q = np.arange(L)
    comp_q  = (~isprime[:L])            # nonprime at q
    ge4     = (q >= 4)                  # q >= 4
    q2prime = isprime[2:L+2]            # (q+2) prime; length L
    T = (comp_q & ge4 & q2prime).astype(np.float64)

    # 3) A[p] = 1_{p prime} for p=0..Xmax
    A = isprime[:L].astype(np.float64)

    # 4) Convolution via FFT: C = T * A of length 2*L - 1
    need = 2*L - 1
    n = 1 << (need - 1).bit_length()
    FA = np.fft.rfft(A, n);  FT = np.fft.rfft(T, n)
    C = np.fft.irfft(FA * FT, n)[:need]

    PCp = np.rint(C).astype(np.int64)[:L]
    zero_set = [int(X) for X in range(6, L, 2) if PCp[X] == 0]
    return PCp, zero_set

# --- demo ---
PCp, zeroes = pcp_exact_up_to_fft(80_000)
print("Zero-set up to 80,000:", zeroes)
# Expected: [6, 8, 10, 36, 210]
